---
title: "복잡한 작업 계획하기"
description: "goose의 Plan 기능을 사용하여 복잡한 작업을 관리 가능하고 실행 가능한 단계로 분해하는 방법을 배웁니다."
---

# 복잡한 작업 계획하기

*압도적인 작업을 체계적이고 단계별 실행 계획으로 변환*


goose를 대규모의 복잡한 작업에 사용하는 것은 특히 사전에 어떻게 접근해야 할지 정확히 모를 때 압도적으로 느껴질 수 있습니다. 제가 출판한 [API 과정](https://github.com/LinkedInLearning/java-automated-api-testing-with-rest-assured-5989068)을 위해 복잡한 개발 환경을 설정해야 했을 때 이를 경험했습니다. Docker 구성, 데이터베이스 초기화, devcontainer 설정, GitHub Codespaces 통합 사이에 완벽하게 함께 작동해야 하는 수십 개의 이동 부품이 있습니다. 하나의 구성이 누락되거나 잘못된 종속성이 있으면 전체 프로세스가 탈선할 수 있습니다.

이 튜토리얼에서는 goose의 [Plan 기능](/docs/guides/creating-plans)을 사용하여 복잡한 devcontainer 설정을 체계적이고 실행 가능한 로드맵으로 변환하는 방법을 보여줍니다. goose와 브레인스토밍하고, 요구 사항을 구체화하고, goose가 상세한 계획과 구현 체크리스트를 모두 만들도록 하는 방법을 배웁니다.

## 학습 내용

이 튜토리얼을 마치면 다음 방법을 이해하게 됩니다:

- goose의 Plan 기능을 사용하여 복잡한 기술 프로젝트 분해
- AI 지원 대화를 통한 브레인스토밍 및 요구 사항 구체화
- 높은 수준의 목표를 상세하고 실행 가능한 단계로 변환
- 검증 및 품질 보증을 위한 포괄적인 체크리스트 생성
- 명확한 산출물로 체계적으로 계획 실행

## 과제: 완전한 Codespaces 환경

목표는 Rest Assured로 API 테스트를 위한 완전한 개발 환경을 제공하는 GitHub 저장소를 만드는 것입니다. 학생들이 GitHub Codespaces에서 저장소를 열면 다음을 갖추어야 합니다:

- **자동화된 설정**: 수동 구성이 필요 없음
- **API 서버**: 자동으로 실행되는 REST API
- **데이터베이스**: 미리 로드된 스키마와 테스트 데이터가 있는 MySQL
- **개발 도구**: Java 17, Docker, 필요한 VS Code 확장 프로그램
- **원클릭 경험**: `docker-compose up -d`로 모든 것 시작

여기에는 Docker, MySQL, PHP, Java, devcontainers, GitHub Codespaces와 같은 여러 기술의 조율이 포함됩니다.


## 1단계: 초기 브레인스토밍 세션

goose와 브레인스토밍 대화를 시작하여 요구 사항을 명확히 합시다.

:::info Desktop vs CLI에서 계획하기
goose Desktop에는 CLI와 같은 `/plan` 키워드가 없습니다. Desktop에서는 goose에게 명시적으로 계획을 만들도록 요청해야 합니다:

```
"Hey goose, can you create a plan to set up my GitHub repo for Codespaces with automatic Docker startup? Please don't start the actual work yet."
```

CLI에서는 `/plan`으로 계획 모드에 들어갈 수 있으며 goose가 계획을 생성하기 전에 명확한 질문을 합니다. goose Desktop에 "계획을 만들어달라"고 구체적으로 요청하지 않으면 바로 구현으로 넘어갈 수 있습니다.
:::

### 대화 시작

**You:** _"자동화된 API 테스트를 위한 GitHub 저장소 설정에 도움이 필요합니다. 학생들이 GitHub Codespaces에서 열면 수동 설정 없이 즉시 테스트 작성을 시작할 수 있어야 합니다. 무엇이 필요한지 함께 생각해 볼 수 있나요?"_

**goose:** _"이 자동화된 설정을 설계하는 것을 기꺼이 도와드리겠습니다! 요구 사항을 더 잘 이해하기 위해 몇 가지 명확한 질문을 드리겠습니다:_

1. 어떤 종류의 API를 사용하고 계신가요? (REST, GraphQL 등)
2. 학생들이 어떤 테스트 프레임워크를 사용하길 원하시나요?
3. 테스트 데이터가 있는 실제 데이터베이스가 필요하신가요, 아니면 모의 응답을 사용할 수 있나요?
4. 학생들이 테스트에 어떤 프로그래밍 언어를 사용해야 하나요?
5. 테스트할 특정 API 엔드포인트나 기능이 있나요?"

### 요구 사항 구체화

**You:** _"학생들이 Java에서 Rest Assured를 사용하여 테스트할 PHP로 만들어진 REST API입니다. 현실적인 시나리오를 연습할 수 있도록 실제 테스트 데이터가 있는 실제 MySQL 데이터베이스가 필요합니다. API에는 전자상거래 시스템에서 제품과 카테고리를 관리하는 엔드포인트가 있습니다."_

**goose:** _"완벽합니다! 명확한 그림이 그려지네요. 올바르게 설계하기 위해 몇 가지 더 질문드리겠습니다:_

1. PHP API 코드를 이미 가지고 계신가요, 아니면 만들어야 하나요?
2. 환경이 어떤 버전의 Java를 지원해야 하나요?
3. MySQL 데이터베이스에 샘플 제품과 카테고리가 채워져야 하나요?
4. 미리 설치할 특정 VS Code 확장 프로그램이 있나요?
5. 이것이 작동하는 데 필요한 일정이 어떻게 되나요?"

**You:** _"현재 MAMP에서 실행되는 기존 PHP API 코드가 있습니다. Rest Assured 호환성을 위해 Java 17이 필요합니다. 네, 데이터베이스에 샘플 데이터가 있어야 합니다. VS Code에 Java 및 Docker 확장 프로그램을 포함해 주세요."_

## 2단계: 상세 계획 생성

이제 요구 사항을 명확히 했으니 goose에게 포괄적인 계획을 만들도록 요청합니다.

### 계획 요청

**You:** _"논의 내용을 바탕으로 이 GitHub 저장소 설정에 대한 상세한 계획을 만들어 줄 수 있나요? 논의한 모든 기술 요구 사항을 다루는 단계별 접근 방식을 원합니다. 각 단계에 대한 구체적인 산출물과 검증 방법을 포함해 주세요."_

### 생성된 계획

goose는 다음과 유사한 포괄적인 계획을 생성합니다:

<details>
  <summary>GitHub Codespaces API 테스트 환경 설정 계획</summary>

```markdown
# GitHub Codespaces API 테스트 환경 설정 계획

## 프로젝트 개요
Rest Assured로 API 테스트를 위한 완전한 개발 환경을 자동으로 프로비저닝하는 GitHub 저장소를 만듭니다. PHP API 서버, MySQL 데이터베이스, Java 개발 도구를 포함합니다.

## 1단계: 저장소 구조 및 API 통합

### 1.1 API 파일 처리
- **산출물**: 저장소에 정리된 API 코드베이스
- **작업**:
  - `/api-server/` 디렉토리를 저장소 루트에 배치
  - PHP 파일을 논리적 구조로 정리

- **검증**: 모든 PHP 파일이 접근 가능하고 적절히 정리됨

### 1.2 데이터베이스 스키마 및 테스트 데이터
- **산출물**: 스키마와 샘플 데이터가 포함된 SQL 파일
- **작업**:
  - 기존 `ApiTestingDB.sql` 파일 검토
  - 스키마 생성과 샘플 데이터 삽입이 모두 포함되어 있는지 확인
  - 샘플 데이터가 현실적인 전자상거래 시나리오를 다루는지 확인
- **검증**: SQL 파일이 오류 없이 실행되고 테스트 데이터가 채워짐

## 2단계: 컨테이너화

### 2.1 API 서버 Docker화
- **산출물**: `api-server/Dockerfile`
- **작업**:
  - `php:8.1-apache` 기본 이미지를 사용하여 Dockerfile 생성
  - 필요한 PHP 확장 프로그램 설치 (`pdo_mysql`)
  - 적절한 파일 권한 및 Apache 설정 구성
- **검증**: Docker 이미지가 성공적으로 빌드되고 PHP 파일을 제공

### 2.2 데이터베이스 컨테이너 설정
- **산출물**: docker-compose.yml의 MySQL 서비스 구성
- **작업**:
  - 적절한 환경 변수로 MySQL 5.7 컨테이너 구성
  - 볼륨 마운팅을 사용한 자동 스키마 초기화 설정
  - PHP-MySQL 통신을 위한 네트워킹 구성
- **검증**: 데이터베이스가 자동으로 시작되고 테스트 데이터로 초기화

### 2.3 서비스 오케스트레이션
- **산출물**: 완전한 `docker-compose.yml`
- **작업**:
  - API 서버 및 MySQL 서비스 모두 정의
  - 적절한 서비스 종속성 구성
  - 외부 액세스를 위한 포트 매핑 설정
  - 데이터베이스 초기화를 위한 볼륨 마운팅 구성
- **검증**: 두 서비스가 올바르게 시작되고 통신 가능

## 3단계: 데이터베이스 연결 구성

### 3.1 PHP 데이터베이스 구성 업데이트
- **산출물**: 업데이트된 `api-server/config/database.php`
- **작업**:
  - Docker 네트워킹을 사용하도록 연결 설정 수정
  - 호스트를 `localhost`에서 `mysql`로 업데이트
  - 자격 증명이 docker-compose 환경 변수와 일치하는지 확인
- **검증**: PHP API가 MySQL 컨테이너에 성공적으로 연결

## 4단계: Codespaces 통합

### 4.1 Devcontainer 구성
- **산출물**: `.devcontainer/devcontainer.json`
- **작업**:
  - Java 17 개발을 위한 devcontainer 구성 생성
  - Docker-in-Docker 기능 활성화
  - 자동 컨테이너 시작 구성
  - 필요한 VS Code 확장 프로그램 미리 설치
- **검증**: Codespace가 모든 도구가 사용 가능한 상태로 실행

## 5단계: 테스트 및 검증

### 5.1 API 액세스 확인
- **작업**:
  - API가 `http://localhost:8888`에서 접근 가능한지 확인
  - 주요 엔드포인트 테스트 (products, categories)
  - 데이터베이스 쿼리가 예상 데이터를 반환하는지 확인
- **검증**: 모든 API 엔드포인트가 올바르게 응답

### 5.2 Codespaces 통합 테스트
- **작업**:
  - GitHub Codespaces에서 저장소 열기
  - 자동 Docker 시작 확인
  - VS Code 확장 프로그램 기능 테스트
  - Java 17 가용성 확인
- **검증**: 학생 사용을 위한 완전한 환경 준비

## 품질 보증 체크리스트

### ✅ API 서버 및 데이터베이스 설정
- [ ] `/api-server/`가 저장소 루트에 배치됨
- [ ] 필요한 모든 디렉토리 존재 (category/, config/, objects/, product/)
- [ ] `ApiTestingDB.sql`에 스키마와 테스트 데이터 포함
- [ ] `Dockerfile`이 `pdo_mysql` 확장 프로그램과 함께 `php:8.1-apache` 사용
- [ ] `docker-compose.yml`이 MySQL 및 API 서비스 모두 정의
- [ ] 서비스가 올바른 종속성 및 포트 매핑으로 구성됨

### ✅ 데이터베이스 구성
- [ ] PHP 데이터베이스 구성이 Docker 네트워킹 사용 (`mysql` 호스트)
- [ ] PHP 구성과 docker-compose 간 자격 증명 일치
- [ ] 데이터베이스가 테스트 데이터로 자동 초기화

### ✅ Codespaces 구성
- [ ] `.devcontainer/` 폴더가 저장소 루트에 존재
- [ ] `devcontainer.json`이 Java 17 환경 지정
- [ ] Docker-in-Docker 기능 활성화
- [ ] `postCreateCommand`가 `docker-compose up -d`로 설정
- [ ] Java 및 Docker VS Code 확장 프로그램 구성됨

### ✅ 통합 테스트
- [ ] Codespace가 오류 없이 실행
- [ ] Docker 서비스가 자동으로 시작
- [ ] API가 `http://localhost:8888`에서 접근 가능
- [ ] 데이터베이스 쿼리가 예상 테스트 데이터 반환
- [ ] Rest Assured 개발을 위한 Java 17 사용 가능
```

</details>

## 3단계: 상세 구현 계획

이제 goose에게 실행을 안내할 구체적인 구현 프롬프트를 만들도록 요청합니다.

### 구현 프롬프트 생성

**You:** _"이 계획이 포괄적으로 보이네요! 이제 이 계획을 실행하는 데 사용할 수 있는 상세한 구현 프롬프트를 만들어 줄 수 있나요? goose가 추가 설명 없이 단계별로 따를 수 있을 만큼 구체적인 것을 원합니다."_

### 구현 프롬프트

goose는 다음과 같은 상세한 프롬프트를 생성합니다:

<details>
    <summary>상세 프롬프트</summary>

```markdown
**작업:**
로컬 API 서버의 자동 Docker 시작과 함께 GitHub Codespaces용 GitHub 저장소를 설정합니다.

**지침:**

1. 저장소 루트에 .devcontainer 폴더를 생성합니다.
2. .devcontainer 내부에 다음이 포함된 devcontainer.json 파일을 생성합니다:
  - Java 17 개발 이미지 사용: "image": "mcr.microsoft.com/devcontainers/java:17"
  - "features": { "docker-in-docker": "latest" } 추가
  - Codespace 빌드 후 Docker 컨테이너를 자동으로 시작하도록 "postCreateCommand": "docker-compose up -d" 설정
  - 선택적으로 Java 및 Docker 지원을 위한 VS Code 확장 프로그램 설치 ("vscode-java-pack" 및 "vscode-docker")

... (나머지 내용 계속)

**산출물:**

- .devcontainer/devcontainer.json
- docker-compose.yml
- (선택) api-server/Dockerfile
- Codespace 준비 완료 확인
```

</details>

## 4단계: 계획 실행

상세한 계획과 구현 프롬프트가 준비되었으므로 이제 설정을 체계적으로 실행할 수 있습니다.

### 구현 시작

**You:** _"완벽합니다! 이제 이 계획을 구현합시다. 다음은 우리가 만든 상세한 프롬프트입니다: [구현 프롬프트 붙여넣기]"_

goose는 이제 계획의 각 단계를 진행하며 필요한 파일과 구성을 생성합니다.

### 진행 상황 모니터링

goose가 계획을 구현할 때 생성한 체크리스트에 대해 각 산출물을 확인할 수 있습니다:

1. **파일 생성**: 필요한 각 파일이 올바른 위치에 생성되었는지 확인
2. **구성 정확성**: 구성이 사양과 일치하는지 확인
3. **통합 지점**: 서비스가 적절하게 연결되고 구성되었는지 확인
4. **테스트 준비**: 환경이 의도한 대로 작동할지 확인

### 검증 및 테스트

구현이 완료되면 계획의 검증 단계를 따릅니다:

```bash
# 로컬에서 Docker 설정 테스트
docker-compose up -d
docker ps

# API 접근성 확인
curl http://localhost:8888/api/products

# 데이터베이스 연결 테스트
docker exec -it mysql mysql -u user -p api_db
```

## 5단계: 반복적 개선

구현 또는 테스트 중 문제가 발생하면 계획을 참조로 사용하여 체계적으로 문제를 식별하고 해결합니다.

### 일반적인 개선 사항

- **포트 충돌**: 충돌이 발생하면 포트 매핑 조정
- **타이밍 문제**: 상태 검사 또는 시작 지연 추가
- **권한 문제**: 적절한 권한으로 Dockerfile 업데이트
- **구성 오류**: 환경 변수 및 연결 문자열 확인

## goose로 계획하기 모범 사례

1. 브레인스토밍으로 시작하세요. 바로 계획을 요청하지 마세요. 요구 사항을 명확히 하고 옵션을 탐색하는 대화를 나누세요.
2. 산출물에 대해 구체적으로 하세요. 각 단계에 대해 구체적인 산출물, 파일 이름, 검증 기준을 요청하세요.
3. goose에게 잠재적인 문제를 식별하고 완화 전략을 제공하도록 요청하세요.
4. 추가 설명 없이 실행을 안내할 수 있는 상세한 구현 프롬프트를 생성하세요.
5. 각 단계가 올바르게 작동했는지 확인하는 구체적인 방법을 포함하세요.

## 고급 계획 기법

### 다단계 계획
매우 복잡한 프로젝트의 경우 계획을 단계로 나누어 점진적으로 진행합니다:

**You:** _"이 계획이 상당히 포괄적이네요. 독립적으로 구현하고 테스트할 수 있는 더 작은 단계로 나눌 수 있나요?"_

### 종속성 매핑
goose에게 작업 간 종속성을 식별하도록 요청합니다:

**You:** _"이 작업 중 어떤 것이 병렬로 수행될 수 있고, 어떤 것이 다른 작업에 종속성이 있나요?"_

### 대안적 접근 방식
다른 구현 전략을 탐색합니다:

**You:** _"이 설정에 대해 더 간단하거나 더 견고할 수 있는 대안적 접근 방식이 있나요?"_

## 결론

goose의 Plan 기능은 복잡한 기술적 도전을 압도적인 문제에서 체계적이고 실행 가능한 로드맵으로 변환합니다. 이 튜토리얼의 접근 방식을 따르면:

1. **브레인스토밍**으로 요구 사항 명확히 하고 옵션 탐색
2. **계획**으로 복잡성을 관리 가능한 단계로 분해
3. **상세화**로 구체적인 구현 지침 생성
4. **실행**을 명확한 검증 기준으로 체계적으로
5. **개선**을 결과와 피드백에 따라 반복적으로

모든 복잡한 개발 환경 설정에 자신감을 가지고 접근할 수 있으며, 성공을 위한 명확한 경로와 구체적인 기준이 있음을 알 수 있습니다.

핵심은 goose를 단순한 코드 생성기가 아닌 계획 파트너로 취급하는 것입니다. 달성하려는 것의 전체 컨텍스트를 제공하고, 구현에 뛰어들기 전에 복잡성을 함께 생각하도록 하세요.

## 다음 단계

- 이 접근 방식을 자신의 복잡한 설정 과제에 시도해 보세요
- 다양한 유형의 계획 프롬프트를 실험해 보세요
- [goose 커뮤니티](https://discord.gg/goose-oss)와 계획 성공 사례를 공유하세요
- 더욱 정교한 워크플로우를 위해 [리드/워커 모드](/docs/tutorials/lead-worker)나 [서브에이전트](/docs/guides/subagents)와 계획이 어떻게 통합되는지 탐색하세요

기억하세요, 목표는 올바른 접근 방식을, 올바른 순서로, 올바른 안전장치와 함께 얻는 것입니다. 이것이 빠른 수정과 견고하고 유지 관리 가능한 솔루션의 차이를 만듭니다.
